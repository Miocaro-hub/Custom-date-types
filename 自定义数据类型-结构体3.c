#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//5.结构体传参
//也可通过函数来给结构体进行初始化,但函数中要传结构体的地址
struct S
{
	int a;
	char c;
	double d;
};

void Init(struct S *ps)  //利用函数初始化
{
	ps->a = 100;
	ps->c = 'w';
	ps->d = 3.14;
}

void Print1(struct S s)  //传值打印
{
	printf("%d %s %lf\n", s.a, s.c, s.d);
}

void Print2(struct S *ps)  //传址打印(这种方式更好,避免了空间不够的麻烦)
{
	printf("%d %s %lf\n", ps->a, ps->c, ps->d);
}

int main()
{
	struct S s = { 0 };
	Init(&s);
	Print1(s);
	Print2(&s);
	return 0;
}

//函数传参的时候,参数是需要压栈,会有时间和空间上的系统开销
//如果传递一个结构体对象的时候,结构体过大,参数压栈的系统开销比较大,所以会导致性能的下降

//结论:结构体传参的时候,要传结构体的地址



//6.结构体实现位段
//位段:C语言允许在一个结构体中以位为单位来指定其成员所占内存长度,这种以位为单位的成员称为"位段"或称"位域"(bit field) 
//位段的声明和结构是类似的,有两个不同:
//1.位段的成员必须是int,unsigned int或signed int或char类型
//2.位段的成员名后边有一个冒号和一个数字

//位段 - 位指的是二进制位

//例如:
struct S
{
	int _a : 2;  //表示_a只需2个bit位,以下同理
	int _b : 5;
	int _c : 10;
	int _d : 30; //若int _d :33; 此时编译就会报错
	//总共需要47个bit位,而6个字节就有48个bit位

	//位段的内存分配
    //1.位段的空间上是按照需要以四个字节(int)或者一个字节(char)的方式来开辟的
    //2.位段涉及很多不确定因素,位段是不跨平台的,注重可移植的程序应该避免使用位段

	//这就可以解释为什么sizeof(s)的结果是8个字节
	//位段一次开辟一个整型的空间,也就是4个字节,32个bit位
	//_a占2个bit位,_b占5个,_c占10个,此时已经占了17个bit位,剩下的15个bit位不足以存放_d
	//所以此时又开辟了一块新的内存,4个字节,32个bit位用来存放_d
	//此时浪费的内存就为存放完_a,_b,_c剩下的15个bit位和存放_d剩下的2个bit位
};

int main()
{
	struct S s;
	printf("%d\n", sizeof(s)); //打印的结果为8,8个字节
	return 0;
}
//使用位段的目的就是为了节省空间


//又一个例子
struct S
{
	char a : 3;  //一次开辟一个字节的空间
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	s.a = 10; //10的二进制表示为1010,占4个bit位,但在结构体中定义a只占用3个bit位,所以存放的时候只存放了010进去
	s.b = 20; //同理,20二进制表示为10100,但b只有4个bit位,所以只存放0100
	s.c = 3; //011,但结构体中定义c占用5个bit位,所以不足的地方用0补齐,c中存放的就为00011
	s.d = 4; //100,补一个0,存放0100
	return 0;
}

//位段的跨平台问题
//1.int位段倍当成有符号还是无符号数是不确定的
//2.位段中最大位的数目不能确定.(16位机器最大16,32位机器最大32,写成int a : 30,在16位机器上就会出问题)
//3.位段中的成员在内存中从左向右分配,还是从右向左分配标准尚未定义
//4.当一个结构包含两个位段,第二个位段成员比较大,无法容纳于第一个位段剩余的位时,是舍弃剩余的位还是利用,这也是不确定的

//总结:跟结构相比,位段可以达到同样的效果,还可以很好的节省空间,但是会有跨平台的问题存在